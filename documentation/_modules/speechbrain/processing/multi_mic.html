

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>speechbrain.processing.multi_mic &mdash; SpeechBrain 0.0.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> SpeechBrain
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting started:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Quick installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#install-via-pypi">Install via PyPI</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#install-locally">Install locally</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../installation.html#test-installation">Test Installation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../experiment.html">Running an experiment</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../experiment.html#yaml-basics">YAML basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../experiment.html#running-arguments">Running arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../experiment.html#tensor-format">Tensor format</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../multigpu.html">Basics of multi-GPU</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../multigpu.html#multi-gpu-training-using-data-parallel">Multi-GPU training using Data Parallel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../multigpu.html#multi-gpu-training-using-distributed-data-parallel-ddp">Multi-GPU training using Distributed Data Parallel (DDP)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../multigpu.html#with-multiple-machines-suppose-you-have-2-servers-with-2-gpus">With multiple machines (suppose you have 2 servers with 2 GPUs):</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing.html#zen-of-speechbrain">Zen of Speechbrain</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing.html#how-to-get-your-code-in-speechbrain">How to get your code in SpeechBrain</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing.html#python">Python</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#version">Version</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#formatting">Formatting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#adding-dependencies">Adding dependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#testing">Testing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing.html#documentation">Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing.html#development-tools">Development tools</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#flake8">flake8</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#pre-commit">pre-commit</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#the-git-pre-commit-hooks">the git pre-commit hooks</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#the-git-pre-push-hooks">the git pre-push hooks</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#pytest-doctests">pytest doctests</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing.html#continuous-integration">Continuous integration</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#what-is-ci">What is CI?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#ci-cd-pipelines">CI / CD Pipelines</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../contributing.html#our-test-suite">Our test suite</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../contributing.html#pull-request-review-guide">Pull Request review guide</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">API Documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../speechbrain.html">Core library (speechbrain)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.core.html">speechbrain.core module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.core.html#summary">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.core.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.yaml.html">speechbrain.yaml module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.alignment.html">speechbrain.alignment</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.alignment.aligner.html">speechbrain.alignment.aligner module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.alignment.aligner.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.alignment.aligner.html#reference">Reference</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.dataio.html">speechbrain.dataio</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.dataio.batch.html">speechbrain.dataio.batch module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.batch.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.batch.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.dataio.dataio.html">speechbrain.dataio.dataio module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.dataio.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.dataio.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.dataio.dataloader.html">speechbrain.dataio.dataloader module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.dataloader.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.dataloader.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.dataio.dataset.html">speechbrain.dataio.dataset module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.dataset.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.dataset.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.dataio.encoder.html">speechbrain.dataio.encoder module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.encoder.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.encoder.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.dataio.legacy.html">speechbrain.dataio.legacy module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.legacy.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.legacy.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.dataio.sampler.html">speechbrain.dataio.sampler module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.sampler.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.sampler.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.dataio.wer.html">speechbrain.dataio.wer module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.wer.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.dataio.wer.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.dataio.html#summary">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.dataio.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.decoders.html">speechbrain.decoders</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.decoders.ctc.html">speechbrain.decoders.ctc module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.decoders.ctc.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.decoders.ctc.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.decoders.seq2seq.html">speechbrain.decoders.seq2seq module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.decoders.seq2seq.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.decoders.seq2seq.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.decoders.transducer.html">speechbrain.decoders.transducer module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.decoders.transducer.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.decoders.transducer.html#reference">Reference</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.lm.html">speechbrain.lm</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.lm.arpa.html">speechbrain.lm.arpa module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lm.arpa.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lm.arpa.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.lm.counting.html">speechbrain.lm.counting module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lm.counting.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lm.counting.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.lm.ngram.html">speechbrain.lm.ngram module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lm.ngram.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lm.ngram.html#reference">Reference</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.lobes.html">speechbrain.lobes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.lobes.augment.html">speechbrain.lobes.augment module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.augment.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.augment.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.lobes.features.html">speechbrain.lobes.features module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.features.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.features.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.lobes.models.html">speechbrain.lobes.models</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.CRDNN.html">speechbrain.lobes.models.CRDNN module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.ContextNet.html">speechbrain.lobes.models.ContextNet module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.ECAPA_TDNN.html">speechbrain.lobes.models.ECAPA_TDNN module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.ESPnetVGG.html">speechbrain.lobes.models.ESPnetVGG module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.MetricGAN_D.html">speechbrain.lobes.models.MetricGAN_D module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.RNNLM.html">speechbrain.lobes.models.RNNLM module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.VanillaNN.html">speechbrain.lobes.models.VanillaNN module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.Xvector.html">speechbrain.lobes.models.Xvector module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.conv_tasnet.html">speechbrain.lobes.models.conv_tasnet module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.convolution.html">speechbrain.lobes.models.convolution module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.dual_path.html">speechbrain.lobes.models.dual_path module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.lobes.models.transformer.html">speechbrain.lobes.models.transformer</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.nnet.html">speechbrain.nnet</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.CNN.html">speechbrain.nnet.CNN module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.CNN.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.CNN.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.RNN.html">speechbrain.nnet.RNN module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.RNN.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.RNN.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.activations.html">speechbrain.nnet.activations module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.activations.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.activations.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.attention.html">speechbrain.nnet.attention module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.attention.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.attention.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.containers.html">speechbrain.nnet.containers module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.containers.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.containers.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.dropout.html">speechbrain.nnet.dropout module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.dropout.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.dropout.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.embedding.html">speechbrain.nnet.embedding module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.embedding.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.embedding.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.linear.html">speechbrain.nnet.linear module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.linear.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.linear.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.losses.html">speechbrain.nnet.losses module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.losses.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.losses.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.normalization.html">speechbrain.nnet.normalization module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.normalization.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.normalization.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.pooling.html">speechbrain.nnet.pooling module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.pooling.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.pooling.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.schedulers.html">speechbrain.nnet.schedulers module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.schedulers.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.schedulers.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.complex_networks.html">speechbrain.nnet.complex_networks</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.complex_networks.c_CNN.html">speechbrain.nnet.complex_networks.c_CNN module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.complex_networks.c_RNN.html">speechbrain.nnet.complex_networks.c_RNN module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.complex_networks.c_linear.html">speechbrain.nnet.complex_networks.c_linear module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.complex_networks.c_normalization.html">speechbrain.nnet.complex_networks.c_normalization module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.complex_networks.c_ops.html">speechbrain.nnet.complex_networks.c_ops module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.loss.html">speechbrain.nnet.loss</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.loss.stoi_loss.html">speechbrain.nnet.loss.stoi_loss module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.loss.transducer_loss.html">speechbrain.nnet.loss.transducer_loss module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.quaternion_networks.html">speechbrain.nnet.quaternion_networks</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.quaternion_networks.q_CNN.html">speechbrain.nnet.quaternion_networks.q_CNN module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.quaternion_networks.q_RNN.html">speechbrain.nnet.quaternion_networks.q_RNN module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.quaternion_networks.q_linear.html">speechbrain.nnet.quaternion_networks.q_linear module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.quaternion_networks.q_normalization.html">speechbrain.nnet.quaternion_networks.q_normalization module</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.quaternion_networks.q_ops.html">speechbrain.nnet.quaternion_networks.q_ops module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.transducer.html">speechbrain.nnet.transducer</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.nnet.transducer.transducer_joint.html">speechbrain.nnet.transducer.transducer_joint module</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.html#summary">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.nnet.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.processing.html">speechbrain.processing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.processing.NMF.html">speechbrain.processing.NMF module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.NMF.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.NMF.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.processing.PLDA_LDA.html">speechbrain.processing.PLDA_LDA module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.PLDA_LDA.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.PLDA_LDA.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.processing.decomposition.html">speechbrain.processing.decomposition module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.decomposition.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.decomposition.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.processing.diarization.html">speechbrain.processing.diarization module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.diarization.html#reference">Reference</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.diarization.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.diarization.html#id1">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.processing.features.html">speechbrain.processing.features module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.features.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.features.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.processing.multi_mic.html">speechbrain.processing.multi_mic module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.multi_mic.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.multi_mic.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.processing.signal_processing.html">speechbrain.processing.signal_processing module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.signal_processing.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.signal_processing.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.processing.speech_augmentation.html">speechbrain.processing.speech_augmentation module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.speech_augmentation.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.processing.speech_augmentation.html#reference">Reference</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.tokenizers.html">speechbrain.tokenizers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.tokenizers.SentencePiece.html">speechbrain.tokenizers.SentencePiece module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.tokenizers.SentencePiece.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.tokenizers.SentencePiece.html#reference">Reference</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.utils.html">speechbrain.utils</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.Accuracy.html">speechbrain.utils.Accuracy module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.Accuracy.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.Accuracy.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.DER.html">speechbrain.utils.DER module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.DER.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.DER.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.checkpoints.html">speechbrain.utils.checkpoints module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.checkpoints.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.checkpoints.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.convert_model.html">speechbrain.utils.convert_model module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.data_pipeline.html">speechbrain.utils.data_pipeline module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.data_pipeline.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.data_pipeline.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.data_utils.html">speechbrain.utils.data_utils module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.data_utils.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.data_utils.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.depgraph.html">speechbrain.utils.depgraph module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.depgraph.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.depgraph.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.distributed.html">speechbrain.utils.distributed module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.distributed.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.distributed.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.edit_distance.html">speechbrain.utils.edit_distance module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.edit_distance.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.edit_distance.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.epoch_loop.html">speechbrain.utils.epoch_loop module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.epoch_loop.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.epoch_loop.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.logger.html">speechbrain.utils.logger module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.logger.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.logger.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.metric_stats.html">speechbrain.utils.metric_stats module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.metric_stats.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.metric_stats.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.parameter_transfer.html">speechbrain.utils.parameter_transfer module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.parameter_transfer.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.parameter_transfer.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.superpowers.html">speechbrain.utils.superpowers module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.superpowers.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.superpowers.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.train_logger.html">speechbrain.utils.train_logger module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.train_logger.html#summary">Summary</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../speechbrain.utils.train_logger.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.html#summary">Summary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../speechbrain.utils.html#reference">Reference</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../speechbrain.html#summary">Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../tools.html">Runnable Tools (tools)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../tools.compute_wer.html">tools.compute_wer</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tools.compute_wer.html#usage">Usage</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">SpeechBrain</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>speechbrain.processing.multi_mic</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for speechbrain.processing.multi_mic</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Multi-microphone components.</span>

<span class="sd">This library contains functions for multi-microphone signal processing.</span>

<span class="sd">Example</span>
<span class="sd">-------</span>
<span class="sd">&gt;&gt;&gt; import torch</span>
<span class="sd">&gt;&gt;&gt;</span>
<span class="sd">&gt;&gt;&gt; from speechbrain.dataio.dataio import read_audio</span>
<span class="sd">&gt;&gt;&gt; from speechbrain.processing.features import STFT, ISTFT</span>
<span class="sd">&gt;&gt;&gt; from speechbrain.processing.multi_mic import Covariance</span>
<span class="sd">&gt;&gt;&gt; from speechbrain.processing.multi_mic import GccPhat, SrpPhat, Music</span>
<span class="sd">&gt;&gt;&gt; from speechbrain.processing.multi_mic import DelaySum, Mvdr, Gev</span>
<span class="sd">&gt;&gt;&gt;</span>
<span class="sd">&gt;&gt;&gt; xs_speech = read_audio(</span>
<span class="sd">...    &#39;samples/audio_samples/multi_mic/speech_-0.82918_0.55279_-0.082918.flac&#39;</span>
<span class="sd">... )</span>
<span class="sd">&gt;&gt;&gt; xs_speech = xs_speech.unsqueeze(0) # [batch, time, channels]</span>
<span class="sd">&gt;&gt;&gt; xs_noise_diff = read_audio(&#39;samples/audio_samples/multi_mic/noise_diffuse.flac&#39;)</span>
<span class="sd">&gt;&gt;&gt; xs_noise_diff = xs_noise_diff.unsqueeze(0)</span>
<span class="sd">&gt;&gt;&gt; xs_noise_loc = read_audio(&#39;samples/audio_samples/multi_mic/noise_0.70225_-0.70225_0.11704.flac&#39;)</span>
<span class="sd">&gt;&gt;&gt; xs_noise_loc =  xs_noise_loc.unsqueeze(0)</span>
<span class="sd">&gt;&gt;&gt; fs = 16000 # sampling rate</span>

<span class="sd">&gt;&gt;&gt; ss = xs_speech</span>
<span class="sd">&gt;&gt;&gt; nn_diff = 0.05 * xs_noise_diff</span>
<span class="sd">&gt;&gt;&gt; nn_loc = 0.05 * xs_noise_loc</span>
<span class="sd">&gt;&gt;&gt; xs_diffused_noise = ss + nn_diff</span>
<span class="sd">&gt;&gt;&gt; xs_localized_noise = ss + nn_loc</span>

<span class="sd">&gt;&gt;&gt; # Delay-and-Sum Beamforming with GCC-PHAT localization</span>
<span class="sd">&gt;&gt;&gt; stft = STFT(sample_rate=fs)</span>
<span class="sd">&gt;&gt;&gt; cov = Covariance()</span>
<span class="sd">&gt;&gt;&gt; gccphat = GccPhat()</span>
<span class="sd">&gt;&gt;&gt; delaysum = DelaySum()</span>
<span class="sd">&gt;&gt;&gt; istft = ISTFT(sample_rate=fs)</span>

<span class="sd">&gt;&gt;&gt; Xs = stft(xs_diffused_noise)</span>
<span class="sd">&gt;&gt;&gt; XXs = cov(Xs)</span>
<span class="sd">&gt;&gt;&gt; tdoas = gccphat(XXs)</span>
<span class="sd">&gt;&gt;&gt; Ys_ds = delaysum(Xs, tdoas)</span>
<span class="sd">&gt;&gt;&gt; ys_ds = istft(Ys_ds)</span>

<span class="sd">&gt;&gt;&gt; # Mvdr Beamforming with SRP-PHAT localization</span>
<span class="sd">&gt;&gt;&gt; mvdr = Mvdr()</span>
<span class="sd">&gt;&gt;&gt; mics = torch.zeros((4,3), dtype=torch.float)</span>
<span class="sd">&gt;&gt;&gt; mics[0,:] = torch.FloatTensor([-0.05, -0.05, +0.00])</span>
<span class="sd">&gt;&gt;&gt; mics[1,:] = torch.FloatTensor([-0.05, +0.05, +0.00])</span>
<span class="sd">&gt;&gt;&gt; mics[2,:] = torch.FloatTensor([+0.05, +0.05, +0.00])</span>
<span class="sd">&gt;&gt;&gt; mics[3,:] = torch.FloatTensor([+0.05, +0.05, +0.00])</span>
<span class="sd">&gt;&gt;&gt; srpphat = SrpPhat(mics=mics)</span>
<span class="sd">&gt;&gt;&gt; doas = srpphat(XXs)</span>
<span class="sd">&gt;&gt;&gt; Ys_mvdr = mvdr(Xs, XXs, doas, doa_mode=True, mics=mics, fs=fs)</span>
<span class="sd">&gt;&gt;&gt; ys_mvdr = istft(Ys_mvdr)</span>

<span class="sd">&gt;&gt;&gt; # Mvdr Beamforming with MUSIC localization</span>
<span class="sd">&gt;&gt;&gt; music = Music(mics=mics)</span>
<span class="sd">&gt;&gt;&gt; doas = music(XXs)</span>
<span class="sd">&gt;&gt;&gt; Ys_mvdr2 = mvdr(Xs, XXs, doas, doa_mode=True, mics=mics, fs=fs)</span>
<span class="sd">&gt;&gt;&gt; ys_mvdr2 = istft(Ys_mvdr2)</span>

<span class="sd">&gt;&gt;&gt; # GeV Beamforming</span>
<span class="sd">&gt;&gt;&gt; gev = Gev()</span>
<span class="sd">&gt;&gt;&gt; Xs = stft(xs_localized_noise)</span>
<span class="sd">&gt;&gt;&gt; Ss = stft(ss)</span>
<span class="sd">&gt;&gt;&gt; Nn = stft(nn_loc)</span>
<span class="sd">&gt;&gt;&gt; SSs = cov(Ss)</span>
<span class="sd">&gt;&gt;&gt; NNs = cov(Nn)</span>
<span class="sd">&gt;&gt;&gt; Ys_gev = gev(Xs, SSs, NNs)</span>
<span class="sd">&gt;&gt;&gt; ys_gev = istft(Ys_gev)</span>

<span class="sd">Authors:</span>
<span class="sd"> * William Aris</span>
<span class="sd"> * Francois Grondin</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">speechbrain.processing.decomposition</span> <span class="k">as</span> <span class="nn">eig</span>


<div class="viewcode-block" id="Covariance"><a class="viewcode-back" href="../../../speechbrain.processing.multi_mic.html#speechbrain.processing.multi_mic.Covariance">[docs]</a><span class="k">class</span> <span class="nc">Covariance</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes the covariance matrices of the signals.</span>

<span class="sd">    Arguments:</span>
<span class="sd">    ----------</span>
<span class="sd">    average : bool</span>
<span class="sd">        Informs the module if it should return an average</span>
<span class="sd">        (computed on the time dimension) of the covariance</span>
<span class="sd">        matrices. The Default value is True.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; import torch</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.dataio.dataio import read_audio</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.processing.features import STFT</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.processing.multi_mic import Covariance</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; xs_speech = read_audio(</span>
<span class="sd">    ...    &#39;samples/audio_samples/multi_mic/speech_-0.82918_0.55279_-0.082918.flac&#39;</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; xs_speech = xs_speech.unsqueeze(0) # [batch, time, channels]</span>
<span class="sd">    &gt;&gt;&gt; xs_noise = read_audio(&#39;samples/audio_samples/multi_mic/noise_diffuse.flac&#39;)</span>
<span class="sd">    &gt;&gt;&gt; xs_noise = xs_noise.unsqueeze(0)</span>
<span class="sd">    &gt;&gt;&gt; xs = xs_speech + 0.05 * xs_noise</span>
<span class="sd">    &gt;&gt;&gt; fs = 16000</span>

<span class="sd">    &gt;&gt;&gt; stft = STFT(sample_rate=fs)</span>
<span class="sd">    &gt;&gt;&gt; cov = Covariance()</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; Xs = stft(xs)</span>
<span class="sd">    &gt;&gt;&gt; XXs = cov(Xs)</span>
<span class="sd">    &gt;&gt;&gt; XXs.shape</span>
<span class="sd">    torch.Size([1, 1001, 201, 2, 10])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">average</span> <span class="o">=</span> <span class="n">average</span>

<div class="viewcode-block" id="Covariance.forward"><a class="viewcode-back" href="../../../speechbrain.processing.multi_mic.html#speechbrain.processing.multi_mic.Covariance.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Xs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; This method uses the utility function _cov to compute covariance</span>
<span class="sd">        matrices. Therefore, the result has the following format:</span>
<span class="sd">        (batch, time_step, n_fft/2 + 1, 2, n_mics + n_pairs).</span>

<span class="sd">        The order on the last dimension corresponds to the triu_indices for a</span>
<span class="sd">        square matrix. For instance, if we have 4 channels, we get the following</span>
<span class="sd">        order: (0, 0), (0, 1), (0, 2), (0, 3), (1, 1), (1, 2), (1, 3), (2, 2), (2, 3)</span>
<span class="sd">        and (3, 3). Therefore, XXs[..., 0] corresponds to channels (0, 0) and XXs[..., 1]</span>
<span class="sd">        corresponds to channels (0, 1).</span>

<span class="sd">        Arguments:</span>
<span class="sd">        ----------</span>
<span class="sd">        Xs : tensor</span>
<span class="sd">            A batch of audio signals in the frequency domain.</span>
<span class="sd">            The tensor must have the following format:</span>
<span class="sd">            (batch, time_step, n_fft/2 + 1, 2, n_mics)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">XXs</span> <span class="o">=</span> <span class="n">Covariance</span><span class="o">.</span><span class="n">_cov</span><span class="p">(</span><span class="n">Xs</span><span class="o">=</span><span class="n">Xs</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">average</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">XXs</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_cov</span><span class="p">(</span><span class="n">Xs</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Computes the covariance matrices (XXs) of the signals. The result will</span>
<span class="sd">        have the following format: (batch, time_step, n_fft/2 + 1, 2, n_mics + n_pairs).</span>

<span class="sd">        Arguments:</span>
<span class="sd">        ----------</span>
<span class="sd">        Xs : tensor</span>
<span class="sd">            A batch of audio signals in the frequency domain.</span>
<span class="sd">            The tensor must have the following format:</span>
<span class="sd">            (batch, time_step, n_fft/2 + 1, 2, n_mics)</span>

<span class="sd">        average : boolean</span>
<span class="sd">            Informs the function if it should return an average</span>
<span class="sd">            (computed on the time dimension) of the covariance</span>
<span class="sd">            matrices. Default value is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get useful dimensions</span>
        <span class="n">n_mics</span> <span class="o">=</span> <span class="n">Xs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>

        <span class="c1"># Formating the real and imaginary parts</span>
        <span class="n">Xs_re</span> <span class="o">=</span> <span class="n">Xs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">Xs_im</span> <span class="o">=</span> <span class="n">Xs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

        <span class="c1"># Computing the covariance</span>
        <span class="n">Rxx_re</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Xs_re</span><span class="p">,</span> <span class="n">Xs_re</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span>
            <span class="n">Xs_im</span><span class="p">,</span> <span class="n">Xs_im</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">Rxx_im</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Xs_re</span><span class="p">,</span> <span class="n">Xs_im</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span>
            <span class="n">Xs_im</span><span class="p">,</span> <span class="n">Xs_re</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Selecting the upper triangular part of the covariance matrices</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="n">n_mics</span><span class="p">,</span> <span class="n">n_mics</span><span class="p">)</span>

        <span class="n">XXs_re</span> <span class="o">=</span> <span class="n">Rxx_re</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">XXs_im</span> <span class="o">=</span> <span class="n">Rxx_im</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="n">XXs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">XXs_re</span><span class="p">,</span> <span class="n">XXs_im</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>

        <span class="c1"># Computing the average if desired</span>
        <span class="k">if</span> <span class="n">average</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">n_time_frames</span> <span class="o">=</span> <span class="n">XXs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">XXs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">XXs</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">XXs</span> <span class="o">=</span> <span class="n">XXs</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_time_frames</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">XXs</span></div>


<div class="viewcode-block" id="DelaySum"><a class="viewcode-back" href="../../../speechbrain.processing.multi_mic.html#speechbrain.processing.multi_mic.DelaySum">[docs]</a><span class="k">class</span> <span class="nc">DelaySum</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Performs delay and sum beamforming by using the TDOAs and</span>
<span class="sd">        the first channel as a reference.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; import torch</span>

<span class="sd">        &gt;&gt;&gt; from speechbrain.dataio.dataio import read_audio</span>
<span class="sd">        &gt;&gt;&gt; from speechbrain.processing.features import STFT, ISTFT</span>
<span class="sd">        &gt;&gt;&gt; from speechbrain.processing.multi_mic import Covariance</span>
<span class="sd">        &gt;&gt;&gt; from speechbrain.processing.multi_mic import GccPhat, DelaySum</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; xs_speech = read_audio(</span>
<span class="sd">        ...    &#39;samples/audio_samples/multi_mic/speech_-0.82918_0.55279_-0.082918.flac&#39;</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; xs_speech = xs_speech. unsqueeze(0) # [batch, time, channel]</span>
<span class="sd">        &gt;&gt;&gt; xs_noise  = read_audio(&#39;samples/audio_samples/multi_mic/noise_diffuse.flac&#39;)</span>
<span class="sd">        &gt;&gt;&gt; xs_noise = xs_noise.unsqueeze(0) #[batch, time, channels]</span>
<span class="sd">        &gt;&gt;&gt; fs = 16000</span>
<span class="sd">        &gt;&gt;&gt; xs = xs_speech + 0.05 * xs_noise</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; stft = STFT(sample_rate=fs)</span>
<span class="sd">        &gt;&gt;&gt; cov = Covariance()</span>
<span class="sd">        &gt;&gt;&gt; gccphat = GccPhat()</span>
<span class="sd">        &gt;&gt;&gt; delaysum = DelaySum()</span>
<span class="sd">        &gt;&gt;&gt; istft = ISTFT(sample_rate=fs)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; Xs = stft(xs)</span>
<span class="sd">        &gt;&gt;&gt; XXs = cov(Xs)</span>
<span class="sd">        &gt;&gt;&gt; tdoas = gccphat(XXs)</span>
<span class="sd">        &gt;&gt;&gt; Ys = delaysum(Xs, tdoas)</span>
<span class="sd">        &gt;&gt;&gt; ys = istft(Ys)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>

<div class="viewcode-block" id="DelaySum.forward"><a class="viewcode-back" href="../../../speechbrain.processing.multi_mic.html#speechbrain.processing.multi_mic.DelaySum.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Xs</span><span class="p">,</span>
        <span class="n">localization_tensor</span><span class="p">,</span>
        <span class="n">doa_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">mics</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">c</span><span class="o">=</span><span class="mf">343.0</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method computes a steering vector by using the TDOAs/DOAs and</span>
<span class="sd">        then calls the utility function _delaysum to perform beamforming.</span>
<span class="sd">        The result has the following format: (batch, time_step, n_fft, 2, 1).</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        Xs : tensor</span>
<span class="sd">            A batch of audio signals in the frequency domain.</span>
<span class="sd">            The tensor must have the following format:</span>
<span class="sd">            (batch, time_step, n_fft/2 + 1, 2, n_mics)</span>
<span class="sd">        localization_tensor : tensor</span>
<span class="sd">            A tensor containing either time differences of arrival (TDOAs)</span>
<span class="sd">            (in samples) for each timestamp or directions of arrival (DOAs)</span>
<span class="sd">            (xyz coordinates in meters). If localization_tensor represents</span>
<span class="sd">            TDOAs, then its format is (batch, time_steps, n_mics + n_pairs).</span>
<span class="sd">            If localization_tensor represents DOAs, then its format is</span>
<span class="sd">            (batch, time_steps, 3)</span>
<span class="sd">        doa_mode : bool</span>
<span class="sd">            The user needs to set this parameter to True if localization_tensor</span>
<span class="sd">            represents DOAs instead of TDOAs. Its default value is set to False.</span>
<span class="sd">        mics : tensor</span>
<span class="sd">            The cartesian position (xyz coordinates in meters) of each microphone.</span>
<span class="sd">            The tensor must have the following format (n_mics, 3). This</span>
<span class="sd">            parameter is only mandatory when localization_tensor represents</span>
<span class="sd">            DOAs.</span>
<span class="sd">        fs : int</span>
<span class="sd">            The sample rate in Hertz of the signals. This parameter is only</span>
<span class="sd">            mandatory when localization_tensor represents DOAs.</span>
<span class="sd">        c : float</span>
<span class="sd">            The speed of sound in the medium. The speed is expressed in meters</span>
<span class="sd">            per second and the default value of this parameter is 343 m/s. This</span>
<span class="sd">            parameter is only used when localization_tensor represents DOAs.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get useful dimensions</span>
        <span class="n">n_fft</span> <span class="o">=</span> <span class="n">Xs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># Convert the tdoas to taus</span>
        <span class="k">if</span> <span class="n">doa_mode</span><span class="p">:</span>
            <span class="n">taus</span> <span class="o">=</span> <span class="n">doas2taus</span><span class="p">(</span><span class="n">doas</span><span class="o">=</span><span class="n">localization_tensor</span><span class="p">,</span> <span class="n">mics</span><span class="o">=</span><span class="n">mics</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">taus</span> <span class="o">=</span> <span class="n">tdoas2taus</span><span class="p">(</span><span class="n">tdoas</span><span class="o">=</span><span class="n">localization_tensor</span><span class="p">)</span>

        <span class="c1"># Generate the steering vector</span>
        <span class="n">As</span> <span class="o">=</span> <span class="n">steering</span><span class="p">(</span><span class="n">taus</span><span class="o">=</span><span class="n">taus</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span>

        <span class="c1"># Apply delay and sum</span>
        <span class="n">Ys</span> <span class="o">=</span> <span class="n">DelaySum</span><span class="o">.</span><span class="n">_delaysum</span><span class="p">(</span><span class="n">Xs</span><span class="o">=</span><span class="n">Xs</span><span class="p">,</span> <span class="n">As</span><span class="o">=</span><span class="n">As</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Ys</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_delaysum</span><span class="p">(</span><span class="n">Xs</span><span class="p">,</span> <span class="n">As</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform delay and sum beamforming. The result has</span>
<span class="sd">        the following format: (batch, time_step, n_fft, 2, 1).</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        Xs : tensor</span>
<span class="sd">            A batch of audio signals in the frequency domain.</span>
<span class="sd">            The tensor must have the following format:</span>
<span class="sd">            (batch, time_step, n_fft/2 + 1, 2, n_mics)</span>
<span class="sd">        As : tensor</span>
<span class="sd">            The steering vector to point in the direction of</span>
<span class="sd">            the target source. The tensor must have the format</span>
<span class="sd">            (batch, time_step, n_fft/2 + 1, 2, n_mics)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get useful dimensions</span>
        <span class="n">n_mics</span> <span class="o">=</span> <span class="n">Xs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>

        <span class="c1"># Generate unmixing coefficients</span>
        <span class="n">Ws_re</span> <span class="o">=</span> <span class="n">As</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">n_mics</span>
        <span class="n">Ws_im</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">As</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">n_mics</span>

        <span class="c1"># Get input signal</span>
        <span class="n">Xs_re</span> <span class="o">=</span> <span class="n">Xs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">Xs_im</span> <span class="o">=</span> <span class="n">Xs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># Applying delay and sum</span>
        <span class="n">Ys_re</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">Ws_re</span> <span class="o">*</span> <span class="n">Xs_re</span> <span class="o">-</span> <span class="n">Ws_im</span> <span class="o">*</span> <span class="n">Xs_im</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">Ys_im</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">Ws_re</span> <span class="o">*</span> <span class="n">Xs_im</span> <span class="o">+</span> <span class="n">Ws_im</span> <span class="o">*</span> <span class="n">Xs_re</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Assembling the result</span>
        <span class="n">Ys</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">Ys_re</span><span class="p">,</span> <span class="n">Ys_im</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Ys</span></div>


<div class="viewcode-block" id="Mvdr"><a class="viewcode-back" href="../../../speechbrain.processing.multi_mic.html#speechbrain.processing.multi_mic.Mvdr">[docs]</a><span class="k">class</span> <span class="nc">Mvdr</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform minimum variance distortionless response (MVDR) beamforming</span>
<span class="sd">    by using an input signal in the frequency domain, its covariance matrices</span>
<span class="sd">    and tdoas (to compute a steering vector).</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; import torch</span>

<span class="sd">        &gt;&gt;&gt; from speechbrain.dataio.dataio import read_audio</span>
<span class="sd">        &gt;&gt;&gt; from speechbrain.processing.features import STFT, ISTFT</span>
<span class="sd">        &gt;&gt;&gt; from speechbrain.processing.multi_mic import Covariance</span>
<span class="sd">        &gt;&gt;&gt; from speechbrain.processing.multi_mic import GccPhat, DelaySum</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; xs_speech = read_audio(</span>
<span class="sd">        ...    &#39;samples/audio_samples/multi_mic/speech_-0.82918_0.55279_-0.082918.flac&#39;</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; xs_speech = xs_speech.unsqueeze(0) # [batch, time, channel]</span>
<span class="sd">        &gt;&gt;&gt; xs_noise  = read_audio(&#39;samples/audio_samples/multi_mic/noise_diffuse.flac&#39;)</span>
<span class="sd">        &gt;&gt;&gt; xs_noise = xs_noise.unsqueeze(0) #[batch, time, channels]</span>
<span class="sd">        &gt;&gt;&gt; fs = 16000</span>
<span class="sd">        &gt;&gt;&gt; xs = xs_speech + 0.05 * xs_noise</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; stft = STFT(sample_rate=fs)</span>
<span class="sd">        &gt;&gt;&gt; cov = Covariance()</span>
<span class="sd">        &gt;&gt;&gt; gccphat = GccPhat()</span>
<span class="sd">        &gt;&gt;&gt; mvdr = Mvdr()</span>
<span class="sd">        &gt;&gt;&gt; istft = ISTFT(sample_rate=fs)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; Xs = stft(xs)</span>
<span class="sd">        &gt;&gt;&gt; XXs = cov(Xs)</span>
<span class="sd">        &gt;&gt;&gt; tdoas = gccphat(XXs)</span>
<span class="sd">        &gt;&gt;&gt; Ys = mvdr(Xs, XXs, tdoas)</span>
<span class="sd">        &gt;&gt;&gt; ys = istft(Ys)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">20</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="n">eps</span>

<div class="viewcode-block" id="Mvdr.forward"><a class="viewcode-back" href="../../../speechbrain.processing.multi_mic.html#speechbrain.processing.multi_mic.Mvdr.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Xs</span><span class="p">,</span>
        <span class="n">XXs</span><span class="p">,</span>
        <span class="n">localization_tensor</span><span class="p">,</span>
        <span class="n">doa_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">mics</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">c</span><span class="o">=</span><span class="mf">343.0</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method computes a steering vector before using the</span>
<span class="sd">        utility function _mvdr to perform beamforming. The result has</span>
<span class="sd">        the following format: (batch, time_step, n_fft, 2, 1).</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        Xs : tensor</span>
<span class="sd">            A batch of audio signals in the frequency domain.</span>
<span class="sd">            The tensor must have the following format:</span>
<span class="sd">            (batch, time_step, n_fft/2 + 1, 2, n_mics)</span>
<span class="sd">        XXs : tensor</span>
<span class="sd">            The covariance matrices of the input signal. The tensor must</span>
<span class="sd">            have the format (batch, time_steps, n_fft/2 + 1, 2, n_mics + n_pairs)</span>
<span class="sd">        localization_tensor : tensor</span>
<span class="sd">            A tensor containing either time differences of arrival (TDOAs)</span>
<span class="sd">            (in samples) for each timestamp or directions of arrival (DOAs)</span>
<span class="sd">            (xyz coordinates in meters). If localization_tensor represents</span>
<span class="sd">            TDOAs, then its format is (batch, time_steps, n_mics + n_pairs).</span>
<span class="sd">            If localization_tensor represents DOAs, then its format is</span>
<span class="sd">            (batch, time_steps, 3)</span>
<span class="sd">        doa_mode : bool</span>
<span class="sd">            The user needs to set this parameter to True if localization_tensor</span>
<span class="sd">            represents DOAs instead of TDOAs. Its default value is set to False.</span>
<span class="sd">        mics : tensor</span>
<span class="sd">            The cartesian position (xyz coordinates in meters) of each microphone.</span>
<span class="sd">            The tensor must have the following format (n_mics, 3). This</span>
<span class="sd">            parameter is only mandatory when localization_tensor represents</span>
<span class="sd">            DOAs.</span>
<span class="sd">        fs : int</span>
<span class="sd">            The sample rate in Hertz of the signals. This parameter is only</span>
<span class="sd">            mandatory when localization_tensor represents DOAs.</span>
<span class="sd">        c : float</span>
<span class="sd">            The speed of sound in the medium. The speed is expressed in meters</span>
<span class="sd">            per second and the default value of this parameter is 343 m/s. This</span>
<span class="sd">            parameter is only used when localization_tensor represents DOAs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get useful dimensions</span>
        <span class="n">n_fft</span> <span class="o">=</span> <span class="n">Xs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># Convert the tdoas to taus</span>
        <span class="k">if</span> <span class="n">doa_mode</span><span class="p">:</span>
            <span class="n">taus</span> <span class="o">=</span> <span class="n">doas2taus</span><span class="p">(</span><span class="n">doas</span><span class="o">=</span><span class="n">localization_tensor</span><span class="p">,</span> <span class="n">mics</span><span class="o">=</span><span class="n">mics</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">taus</span> <span class="o">=</span> <span class="n">tdoas2taus</span><span class="p">(</span><span class="n">tdoas</span><span class="o">=</span><span class="n">localization_tensor</span><span class="p">)</span>

        <span class="c1"># Generate the steering vector</span>
        <span class="n">As</span> <span class="o">=</span> <span class="n">steering</span><span class="p">(</span><span class="n">taus</span><span class="o">=</span><span class="n">taus</span><span class="p">,</span> <span class="n">n_fft</span><span class="o">=</span><span class="n">n_fft</span><span class="p">)</span>

        <span class="c1"># Perform mvdr</span>
        <span class="n">Ys</span> <span class="o">=</span> <span class="n">Mvdr</span><span class="o">.</span><span class="n">_mvdr</span><span class="p">(</span><span class="n">Xs</span><span class="o">=</span><span class="n">Xs</span><span class="p">,</span> <span class="n">XXs</span><span class="o">=</span><span class="n">XXs</span><span class="p">,</span> <span class="n">As</span><span class="o">=</span><span class="n">As</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Ys</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_mvdr</span><span class="p">(</span><span class="n">Xs</span><span class="p">,</span> <span class="n">XXs</span><span class="p">,</span> <span class="n">As</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">20</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform minimum variance distortionless response beamforming.</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        Xs : tensor</span>
<span class="sd">            A batch of audio signals in the frequency domain.</span>
<span class="sd">            The tensor must have the following format:</span>
<span class="sd">            (batch, time_step, n_fft/2 + 1, 2, n_mics).</span>
<span class="sd">        XXs : tensor</span>
<span class="sd">            The covariance matrices of the input signal. The tensor must</span>
<span class="sd">            have the format (batch, time_steps, n_fft/2 + 1, 2, n_mics + n_pairs).</span>
<span class="sd">        As : tensor</span>
<span class="sd">            The steering vector to point in the direction of</span>
<span class="sd">            the target source. The tensor must have the format</span>
<span class="sd">            (batch, time_step, n_fft/2 + 1, 2, n_mics).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get unique covariance values to reduce the number of computations</span>
        <span class="n">XXs_val</span><span class="p">,</span> <span class="n">XXs_idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">XXs</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Inverse covariance matrices</span>
        <span class="n">XXs_inv</span> <span class="o">=</span> <span class="n">eig</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">XXs_val</span><span class="p">)</span>

        <span class="c1"># Capture real and imaginary parts, and restore time steps</span>
        <span class="n">XXs_inv_re</span> <span class="o">=</span> <span class="n">XXs_inv</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">][:,</span> <span class="n">XXs_idx</span><span class="p">]</span>
        <span class="n">XXs_inv_im</span> <span class="o">=</span> <span class="n">XXs_inv</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">][:,</span> <span class="n">XXs_idx</span><span class="p">]</span>

        <span class="c1"># Decompose steering vector</span>
        <span class="n">AsC_re</span> <span class="o">=</span> <span class="n">As</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">AsC_im</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">As</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">AsT_re</span> <span class="o">=</span> <span class="n">AsC_re</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">AsT_im</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">AsC_im</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

        <span class="c1"># Project</span>
        <span class="n">XXs_inv_AsC_re</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">XXs_inv_re</span><span class="p">,</span> <span class="n">AsC_re</span><span class="p">)</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span>
            <span class="n">XXs_inv_im</span><span class="p">,</span> <span class="n">AsC_im</span>
        <span class="p">)</span>
        <span class="n">XXs_inv_AsC_im</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">XXs_inv_re</span><span class="p">,</span> <span class="n">AsC_im</span><span class="p">)</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span>
            <span class="n">XXs_inv_im</span><span class="p">,</span> <span class="n">AsC_re</span>
        <span class="p">)</span>

        <span class="c1"># Compute the gain</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">AsT_re</span><span class="p">,</span> <span class="n">XXs_inv_AsC_re</span><span class="p">)</span>
            <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">AsT_im</span><span class="p">,</span> <span class="n">XXs_inv_AsC_im</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Get the unmixing coefficients</span>
        <span class="n">Ws_re</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">XXs_inv_AsC_re</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">Ws_im</span> <span class="o">=</span> <span class="o">-</span><span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">XXs_inv_AsC_im</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

        <span class="c1"># Applying MVDR</span>
        <span class="n">Xs_re</span> <span class="o">=</span> <span class="n">Xs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">Xs_im</span> <span class="o">=</span> <span class="n">Xs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">Ys_re</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">Ws_re</span> <span class="o">*</span> <span class="n">Xs_re</span> <span class="o">-</span> <span class="n">Ws_im</span> <span class="o">*</span> <span class="n">Xs_im</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">Ys_im</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">Ws_re</span> <span class="o">*</span> <span class="n">Xs_im</span> <span class="o">+</span> <span class="n">Ws_im</span> <span class="o">*</span> <span class="n">Xs_re</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">Ys</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">Ys_re</span><span class="p">,</span> <span class="n">Ys_im</span><span class="p">),</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Ys</span></div>


<div class="viewcode-block" id="Gev"><a class="viewcode-back" href="../../../speechbrain.processing.multi_mic.html#speechbrain.processing.multi_mic.Gev">[docs]</a><span class="k">class</span> <span class="nc">Gev</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generalized EigenValue decomposition (GEV) Beamforming.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.dataio.dataio import read_audio</span>
<span class="sd">    &gt;&gt;&gt; import torch</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.processing.features import STFT, ISTFT</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.processing.multi_mic import Covariance</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.processing.multi_mic import Gev</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; xs_speech = read_audio(</span>
<span class="sd">    ...    &#39;samples/audio_samples/multi_mic/speech_-0.82918_0.55279_-0.082918.flac&#39;</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; xs_speech  = xs_speech.unsqueeze(0) # [batch, time, channels]</span>
<span class="sd">    &gt;&gt;&gt; xs_noise = read_audio(&#39;samples/audio_samples/multi_mic/noise_0.70225_-0.70225_0.11704.flac&#39;)</span>
<span class="sd">    &gt;&gt;&gt; xs_noise = xs_noise.unsqueeze(0)</span>
<span class="sd">    &gt;&gt;&gt; fs = 16000</span>
<span class="sd">    &gt;&gt;&gt; ss = xs_speech</span>
<span class="sd">    &gt;&gt;&gt; nn = 0.05 * xs_noise</span>
<span class="sd">    &gt;&gt;&gt; xs = ss + nn</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; stft = STFT(sample_rate=fs)</span>
<span class="sd">    &gt;&gt;&gt; cov = Covariance()</span>
<span class="sd">    &gt;&gt;&gt; gev = Gev()</span>
<span class="sd">    &gt;&gt;&gt; istft = ISTFT(sample_rate=fs)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; Ss = stft(ss)</span>
<span class="sd">    &gt;&gt;&gt; Nn = stft(nn)</span>
<span class="sd">    &gt;&gt;&gt; Xs = stft(xs)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; SSs = cov(Ss)</span>
<span class="sd">    &gt;&gt;&gt; NNs = cov(Nn)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; Ys = gev(Xs, SSs, NNs)</span>
<span class="sd">    &gt;&gt;&gt; ys = istft(Ys)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>

<div class="viewcode-block" id="Gev.forward"><a class="viewcode-back" href="../../../speechbrain.processing.multi_mic.html#speechbrain.processing.multi_mic.Gev.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Xs</span><span class="p">,</span> <span class="n">SSs</span><span class="p">,</span> <span class="n">NNs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; This method uses the utility function _gev to perform generalized</span>
<span class="sd">        eigenvalue decomposition beamforming. Therefore, the result has</span>
<span class="sd">        the following format: (batch, time_step, n_fft, 2, 1).</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        Xs : tensor</span>
<span class="sd">            A batch of audio signals in the frequency domain.</span>
<span class="sd">            The tensor must have the following format:</span>
<span class="sd">            (batch, time_step, n_fft/2 + 1, 2, n_mics).</span>
<span class="sd">        SSs : tensor</span>
<span class="sd">            The covariance matrices of the target signal. The tensor must</span>
<span class="sd">            have the format (batch, time_steps, n_fft/2 + 1, 2, n_mics + n_pairs).</span>
<span class="sd">        NNs : tensor</span>
<span class="sd">            The covariance matrices of the noise signal. The tensor must</span>
<span class="sd">            have the format (batch, time_steps, n_fft/2 + 1, 2, n_mics + n_pairs).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">Ys</span> <span class="o">=</span> <span class="n">Gev</span><span class="o">.</span><span class="n">_gev</span><span class="p">(</span><span class="n">Xs</span><span class="o">=</span><span class="n">Xs</span><span class="p">,</span> <span class="n">SSs</span><span class="o">=</span><span class="n">SSs</span><span class="p">,</span> <span class="n">NNs</span><span class="o">=</span><span class="n">NNs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Ys</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gev</span><span class="p">(</span><span class="n">Xs</span><span class="p">,</span> <span class="n">SSs</span><span class="p">,</span> <span class="n">NNs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Perform generalized eigenvalue decomposition beamforming. The result</span>
<span class="sd">        has the following format: (batch, time_step, n_fft, 2, 1).</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        Xs : tensor</span>
<span class="sd">            A batch of audio signals in the frequency domain.</span>
<span class="sd">            The tensor must have the following format:</span>
<span class="sd">            (batch, time_step, n_fft/2 + 1, 2, n_mics).</span>
<span class="sd">        SSs : tensor</span>
<span class="sd">            The covariance matrices of the target signal. The tensor must</span>
<span class="sd">            have the format (batch, time_steps, n_fft/2 + 1, 2, n_mics + n_pairs).</span>
<span class="sd">        NNs : tensor</span>
<span class="sd">            The covariance matrices of the noise signal. The tensor must</span>
<span class="sd">            have the format (batch, time_steps, n_fft/2 + 1, 2, n_mics + n_pairs).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get useful dimensions</span>
        <span class="n">n_mics</span> <span class="o">=</span> <span class="n">Xs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">n_mics_pairs</span> <span class="o">=</span> <span class="n">SSs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>

        <span class="c1"># Computing the eigenvectors</span>
        <span class="n">SSs_NNs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">SSs</span><span class="p">,</span> <span class="n">NNs</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">SSs_NNs_val</span><span class="p">,</span> <span class="n">SSs_NNs_idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
            <span class="n">SSs_NNs</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>

        <span class="n">SSs</span> <span class="o">=</span> <span class="n">SSs_NNs_val</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_mics_pairs</span><span class="p">)]</span>
        <span class="n">NNs</span> <span class="o">=</span> <span class="n">SSs_NNs_val</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_mics_pairs</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n_mics_pairs</span><span class="p">)]</span>
        <span class="n">NNs</span> <span class="o">=</span> <span class="n">eig</span><span class="o">.</span><span class="n">pos_def</span><span class="p">(</span><span class="n">NNs</span><span class="p">)</span>
        <span class="n">Vs</span><span class="p">,</span> <span class="n">Ds</span> <span class="o">=</span> <span class="n">eig</span><span class="o">.</span><span class="n">gevd</span><span class="p">(</span><span class="n">SSs</span><span class="p">,</span> <span class="n">NNs</span><span class="p">)</span>

        <span class="c1"># Beamforming</span>
        <span class="n">F_re</span> <span class="o">=</span> <span class="n">Vs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">(</span><span class="n">n_mics</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">F_im</span> <span class="o">=</span> <span class="n">Vs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">(</span><span class="n">n_mics</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Normalize</span>
        <span class="n">F_norm</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">F_re</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">F_im</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
        <span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_mics</span><span class="p">)</span>
        <span class="n">F_re</span> <span class="o">*=</span> <span class="n">F_norm</span>
        <span class="n">F_im</span> <span class="o">*=</span> <span class="n">F_norm</span>

        <span class="n">Ws_re</span> <span class="o">=</span> <span class="n">F_re</span><span class="p">[:,</span> <span class="n">SSs_NNs_idx</span><span class="p">]</span>
        <span class="n">Ws_im</span> <span class="o">=</span> <span class="n">F_im</span><span class="p">[:,</span> <span class="n">SSs_NNs_idx</span><span class="p">]</span>

        <span class="n">Xs_re</span> <span class="o">=</span> <span class="n">Xs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">Xs_im</span> <span class="o">=</span> <span class="n">Xs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">Ys_re</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">Ws_re</span> <span class="o">*</span> <span class="n">Xs_re</span> <span class="o">-</span> <span class="n">Ws_im</span> <span class="o">*</span> <span class="n">Xs_im</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">Ys_im</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">Ws_re</span> <span class="o">*</span> <span class="n">Xs_im</span> <span class="o">+</span> <span class="n">Ws_im</span> <span class="o">*</span> <span class="n">Xs_re</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Assembling the output</span>
        <span class="n">Ys</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">Ys_re</span><span class="p">,</span> <span class="n">Ys_im</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Ys</span></div>


<div class="viewcode-block" id="GccPhat"><a class="viewcode-back" href="../../../speechbrain.processing.multi_mic.html#speechbrain.processing.multi_mic.GccPhat">[docs]</a><span class="k">class</span> <span class="nc">GccPhat</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generalized Cross-Correlation with Phase Transform localization.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    tdoa_max : int</span>
<span class="sd">        Specifies a range to search for delays. For example, if</span>
<span class="sd">        tdoa_max = 10, the method will restrict its search for delays</span>
<span class="sd">        between -10 and 10 samples. This parameter is optional and its</span>
<span class="sd">        default value is None. When tdoa_max is None, the method will</span>
<span class="sd">        search for delays between -n_fft/2 and n_fft/2 (full range).</span>
<span class="sd">    eps : float</span>
<span class="sd">        A small value to avoid divisions by 0 with the phase transformation.</span>
<span class="sd">        The default value is 1e-20.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; import torch</span>

<span class="sd">    &gt;&gt;&gt; from speechbrain.dataio.dataio import read_audio</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.processing.features import STFT, ISTFT</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.processing.multi_mic import Covariance</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.processing.multi_mic import GccPhat, DelaySum</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; xs_speech = read_audio(</span>
<span class="sd">    ...    &#39;samples/audio_samples/multi_mic/speech_-0.82918_0.55279_-0.082918.flac&#39;</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; xs_speech = xs_speech.unsqueeze(0) # [batch, time, channel]</span>
<span class="sd">    &gt;&gt;&gt; xs_noise  = read_audio(&#39;samples/audio_samples/multi_mic/noise_diffuse.flac&#39;)</span>
<span class="sd">    &gt;&gt;&gt; xs_noise = xs_noise.unsqueeze(0) #[batch, time, channels]</span>
<span class="sd">    &gt;&gt;&gt; fs = 16000</span>
<span class="sd">    &gt;&gt;&gt; xs = xs_speech + 0.05 * xs_noise</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; stft = STFT(sample_rate=fs)</span>
<span class="sd">    &gt;&gt;&gt; cov = Covariance()</span>
<span class="sd">    &gt;&gt;&gt; gccphat = GccPhat()</span>
<span class="sd">    &gt;&gt;&gt; Xs = stft(xs)</span>
<span class="sd">    &gt;&gt;&gt; XXs = cov(Xs)</span>
<span class="sd">    &gt;&gt;&gt; tdoas = gccphat(XXs)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tdoa_max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">20</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tdoa_max</span> <span class="o">=</span> <span class="n">tdoa_max</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="n">eps</span>

<div class="viewcode-block" id="GccPhat.forward"><a class="viewcode-back" href="../../../speechbrain.processing.multi_mic.html#speechbrain.processing.multi_mic.GccPhat.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">XXs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Perform generalized cross-correlation with phase transform localization</span>
<span class="sd">        by using the utility function _gcc_phat and by extracting the delays (in samples)</span>
<span class="sd">        before performing a quadratic interpolation to improve the accuracy.</span>
<span class="sd">        The result has the format: (batch, time_steps, n_mics + n_pairs).</span>

<span class="sd">        The order on the last dimension corresponds to the triu_indices for a</span>
<span class="sd">        square matrix. For instance, if we have 4 channels, we get the following</span>
<span class="sd">        order: (0, 0), (0, 1), (0, 2), (0, 3), (1, 1), (1, 2), (1, 3), (2, 2), (2, 3)</span>
<span class="sd">        and (3, 3). Therefore, delays[..., 0] corresponds to channels (0, 0) and delays[..., 1]</span>
<span class="sd">        corresponds to channels (0, 1).</span>

<span class="sd">        Arguments:</span>
<span class="sd">        ----------</span>
<span class="sd">        XXs : tensor</span>
<span class="sd">            The covariance matrices of the input signal. The tensor must</span>
<span class="sd">            have the format (batch, time_steps, n_fft/2 + 1, 2, n_mics + n_pairs).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">xxs</span> <span class="o">=</span> <span class="n">GccPhat</span><span class="o">.</span><span class="n">_gcc_phat</span><span class="p">(</span><span class="n">XXs</span><span class="o">=</span><span class="n">XXs</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
        <span class="n">delays</span> <span class="o">=</span> <span class="n">GccPhat</span><span class="o">.</span><span class="n">_extract_delays</span><span class="p">(</span><span class="n">xxs</span><span class="o">=</span><span class="n">xxs</span><span class="p">,</span> <span class="n">tdoa_max</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tdoa_max</span><span class="p">)</span>
        <span class="n">tdoas</span> <span class="o">=</span> <span class="n">GccPhat</span><span class="o">.</span><span class="n">_interpolate</span><span class="p">(</span><span class="n">xxs</span><span class="o">=</span><span class="n">xxs</span><span class="p">,</span> <span class="n">delays</span><span class="o">=</span><span class="n">delays</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tdoas</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gcc_phat</span><span class="p">(</span><span class="n">XXs</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">20</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Evaluate GCC-PHAT for each timestamp. It returns the result in the time</span>
<span class="sd">        domain. The result has the format: (batch, time_steps, n_fft, n_mics + n_pairs).</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        XXs : tensor</span>
<span class="sd">            The covariance matrices of the input signal. The tensor must</span>
<span class="sd">            have the format (batch, time_steps, n_fft/2 + 1, 2, n_mics + n_pairs).</span>
<span class="sd">        eps : float</span>
<span class="sd">            A small value to avoid divisions by 0 with the phase transform. The</span>
<span class="sd">            default value is 1e-20.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get useful dimensions</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">XXs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Extracting the tensors needed</span>
        <span class="n">XXs_val</span><span class="p">,</span> <span class="n">XXs_idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">XXs</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

        <span class="n">XXs_re</span> <span class="o">=</span> <span class="n">XXs_val</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">XXs_im</span> <span class="o">=</span> <span class="n">XXs_val</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># Applying the phase transform</span>
        <span class="n">XXs_abs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">XXs_re</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">XXs_im</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">eps</span>
        <span class="n">XXs_re_phat</span> <span class="o">=</span> <span class="n">XXs_re</span> <span class="o">/</span> <span class="n">XXs_abs</span>
        <span class="n">XXs_im_phat</span> <span class="o">=</span> <span class="n">XXs_im</span> <span class="o">/</span> <span class="n">XXs_abs</span>
        <span class="n">XXs_phat</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">XXs_re_phat</span><span class="p">,</span> <span class="n">XXs_im_phat</span><span class="p">),</span> <span class="mi">4</span><span class="p">)</span>

        <span class="c1"># Returning in the temporal domain</span>
        <span class="n">XXs_phat</span> <span class="o">=</span> <span class="n">XXs_phat</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">xxs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">XXs_phat</span><span class="p">,</span> <span class="n">signal_ndim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">signal_sizes</span><span class="o">=</span><span class="p">[</span><span class="n">n_samples</span><span class="p">])</span>
        <span class="n">xxs</span> <span class="o">=</span> <span class="n">xxs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">XXs_idx</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># Formatting the output</span>
        <span class="n">xxs</span> <span class="o">=</span> <span class="n">xxs</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">xxs</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_extract_delays</span><span class="p">(</span><span class="n">xxs</span><span class="p">,</span> <span class="n">tdoa_max</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Extract the rounded delays from the cross-correlation for each timestamp.</span>
<span class="sd">        The result has the format: (batch, time_steps, n_mics + n_pairs).</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        xxs : tensor</span>
<span class="sd">            The correlation signals obtained after a gcc-phat operation. The tensor</span>
<span class="sd">            must have the format (batch, time_steps, n_fft, n_mics + n_pairs).</span>
<span class="sd">        tdoa_max : int</span>
<span class="sd">            Specifies a range to search for delays. For example, if</span>
<span class="sd">            tdoa_max = 10, the method will restrict its search for delays</span>
<span class="sd">            between -10 and 10 samples. This parameter is optional and its</span>
<span class="sd">            default value is None. When tdoa_max is None, the method will</span>
<span class="sd">            search for delays between -n_fft/2 and +n_fft/2 (full range).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get useful dimensions</span>
        <span class="n">n_fft</span> <span class="o">=</span> <span class="n">xxs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># If no tdoa specified, cover the whole frame</span>
        <span class="k">if</span> <span class="n">tdoa_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tdoa_max</span> <span class="o">=</span> <span class="n">n_fft</span> <span class="o">//</span> <span class="mi">2</span>

        <span class="c1"># Splitting the GCC-PHAT values to search in the range</span>
        <span class="n">slice_1</span> <span class="o">=</span> <span class="n">xxs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">tdoa_max</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">slice_2</span> <span class="o">=</span> <span class="n">xxs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="n">tdoa_max</span><span class="p">:,</span> <span class="p">:]</span>

        <span class="n">xxs_sliced</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">slice_1</span><span class="p">,</span> <span class="n">slice_2</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Extracting the delays in the range</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">delays</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xxs_sliced</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Adjusting the delays that were affected by the slicing</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">n_fft</span> <span class="o">-</span> <span class="n">xxs_sliced</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">delays</span> <span class="o">&gt;=</span> <span class="n">slice_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">delays</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">offset</span>

        <span class="c1"># Centering the delays around 0</span>
        <span class="n">delays</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-=</span> <span class="n">n_fft</span>

        <span class="k">return</span> <span class="n">delays</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_interpolate</span><span class="p">(</span><span class="n">xxs</span><span class="p">,</span> <span class="n">delays</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform quadratic interpolation on the cross-correlation to</span>
<span class="sd">        improve the tdoa accuracy. The result has the format:</span>
<span class="sd">        (batch, time_steps, n_mics + n_pairs)</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        xxs : tensor</span>
<span class="sd">            The correlation signals obtained after a gcc-phat operation. The tensor</span>
<span class="sd">            must have the format (batch, time_steps, n_fft, n_mics + n_pairs).</span>
<span class="sd">        delays : tensor</span>
<span class="sd">            The rounded tdoas obtained by selecting the sample with the highest</span>
<span class="sd">            amplitude. The tensor must have the format</span>
<span class="sd">            (batch, time_steps, n_mics + n_pairs).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get useful dimensions</span>
        <span class="n">n_fft</span> <span class="o">=</span> <span class="n">xxs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># Get the max amplitude and its neighbours</span>
        <span class="n">tp</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">fmod</span><span class="p">((</span><span class="n">delays</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">n_fft</span><span class="p">,</span> <span class="n">n_fft</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">xxs</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">tp</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">tp</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">fmod</span><span class="p">(</span><span class="n">delays</span> <span class="o">+</span> <span class="n">n_fft</span><span class="p">,</span> <span class="n">n_fft</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">y2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">xxs</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">tp</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">tp</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">fmod</span><span class="p">((</span><span class="n">delays</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">n_fft</span><span class="p">,</span> <span class="n">n_fft</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">y3</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">xxs</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">tp</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Add a fractional part to the initially rounded delay</span>
        <span class="n">delays_frac</span> <span class="o">=</span> <span class="n">delays</span> <span class="o">+</span> <span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y3</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">y1</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">y2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y3</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">delays_frac</span></div>


<div class="viewcode-block" id="SrpPhat"><a class="viewcode-back" href="../../../speechbrain.processing.multi_mic.html#speechbrain.processing.multi_mic.SrpPhat">[docs]</a><span class="k">class</span> <span class="nc">SrpPhat</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Steered-Response Power with Phase Transform Localization.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    mics : tensor</span>
<span class="sd">        The cartesian coordinates (xyz) in meters of each microphone.</span>
<span class="sd">        The tensor must have the following format (n_mics, 3).</span>
<span class="sd">    space : string</span>
<span class="sd">        If this parameter is set to &#39;sphere&#39;, the localization will</span>
<span class="sd">        be done in 3D by searching in a sphere of possible doas. If</span>
<span class="sd">        it set to &#39;circle&#39;, the search will be done in 2D by searching</span>
<span class="sd">        in a circle. By default, this parameter is set to &#39;sphere&#39;.</span>
<span class="sd">        Note: The &#39;circle&#39; option isn&#39;t implemented yet.</span>
<span class="sd">    sample_rate : int</span>
<span class="sd">        The sample rate in Hertz of the signals to perform SRP-PHAT on.</span>
<span class="sd">        By default, this parameter is set to 16000 Hz.</span>
<span class="sd">    speed_sound : float</span>
<span class="sd">        The speed of sound in the medium. The speed is expressed in meters</span>
<span class="sd">        per second and the default value of this parameter is 343 m/s.</span>
<span class="sd">    eps : float</span>
<span class="sd">        A small value to avoid errors like division by 0. The default value</span>
<span class="sd">        of this parameter is 1e-20.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; import torch</span>

<span class="sd">    &gt;&gt;&gt; from speechbrain.dataio.dataio import read_audio</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.processing.features import STFT</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.processing.multi_mic import Covariance</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.processing.multi_mic import SrpPhat</span>

<span class="sd">    &gt;&gt;&gt; xs_speech = read_audio(&#39;samples/audio_samples/multi_mic/speech_-0.82918_0.55279_-0.082918.flac&#39;)</span>
<span class="sd">    &gt;&gt;&gt; xs_noise = read_audio(&#39;samples/audio_samples/multi_mic/noise_diffuse.flac&#39;)</span>
<span class="sd">    &gt;&gt;&gt; fs = 16000</span>

<span class="sd">    &gt;&gt;&gt; xs_speech = xs_speech.unsqueeze(0) # [batch, time, channels]</span>
<span class="sd">    &gt;&gt;&gt; xs_noise = xs_noise.unsqueeze(0)</span>

<span class="sd">    &gt;&gt;&gt; ss1 = xs_speech</span>
<span class="sd">    &gt;&gt;&gt; ns1 = 0.05 * xs_noise</span>
<span class="sd">    &gt;&gt;&gt; xs1 = ss1 + ns1</span>

<span class="sd">    &gt;&gt;&gt; ss2 = xs_speech</span>
<span class="sd">    &gt;&gt;&gt; ns2 = 0.20 * xs_noise</span>
<span class="sd">    &gt;&gt;&gt; xs2 = ss2 + ns2</span>

<span class="sd">    &gt;&gt;&gt; ss = torch.cat((ss1,ss2), dim=0)</span>
<span class="sd">    &gt;&gt;&gt; ns = torch.cat((ns1,ns2), dim=0)</span>
<span class="sd">    &gt;&gt;&gt; xs = torch.cat((xs1,xs2), dim=0)</span>

<span class="sd">    &gt;&gt;&gt; mics = torch.zeros((4,3), dtype=torch.float)</span>
<span class="sd">    &gt;&gt;&gt; mics[0,:] = torch.FloatTensor([-0.05, -0.05, +0.00])</span>
<span class="sd">    &gt;&gt;&gt; mics[1,:] = torch.FloatTensor([-0.05, +0.05, +0.00])</span>
<span class="sd">    &gt;&gt;&gt; mics[2,:] = torch.FloatTensor([+0.05, +0.05, +0.00])</span>
<span class="sd">    &gt;&gt;&gt; mics[3,:] = torch.FloatTensor([+0.05, +0.05, +0.00])</span>

<span class="sd">    &gt;&gt;&gt; stft = STFT(sample_rate=fs)</span>
<span class="sd">    &gt;&gt;&gt; cov = Covariance()</span>
<span class="sd">    &gt;&gt;&gt; srpphat = SrpPhat(mics=mics)</span>

<span class="sd">    &gt;&gt;&gt; Xs = stft(xs)</span>
<span class="sd">    &gt;&gt;&gt; XXs = cov(Xs)</span>
<span class="sd">    &gt;&gt;&gt; doas = srpphat(XXs)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mics</span><span class="p">,</span>
        <span class="n">space</span><span class="o">=</span><span class="s2">&quot;sphere&quot;</span><span class="p">,</span>
        <span class="n">sample_rate</span><span class="o">=</span><span class="mi">16000</span><span class="p">,</span>
        <span class="n">speed_sound</span><span class="o">=</span><span class="mf">343.0</span><span class="p">,</span>
        <span class="n">eps</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>

        <span class="c1"># Generate the doas</span>
        <span class="k">if</span> <span class="n">space</span> <span class="o">==</span> <span class="s2">&quot;sphere&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">doas</span> <span class="o">=</span> <span class="n">sphere</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">space</span> <span class="o">==</span> <span class="s2">&quot;circle&quot;</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># Generate associated taus with the doas</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">taus</span> <span class="o">=</span> <span class="n">doas2taus</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">doas</span><span class="p">,</span> <span class="n">mics</span><span class="o">=</span><span class="n">mics</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">speed_sound</span>
        <span class="p">)</span>

        <span class="c1"># Save epsilon</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="n">eps</span>

<div class="viewcode-block" id="SrpPhat.forward"><a class="viewcode-back" href="../../../speechbrain.processing.multi_mic.html#speechbrain.processing.multi_mic.SrpPhat.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">XXs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Perform SRP-PHAT localization on a signal by computing a steering</span>
<span class="sd">        vector and then by using the utility function _srp_phat to extract the doas.</span>
<span class="sd">        The result is a tensor containing the directions of arrival (xyz coordinates</span>
<span class="sd">        (in meters) in the direction of the sound source). The output tensor</span>
<span class="sd">        has the format (batch, time_steps, 3).</span>

<span class="sd">        This localization method uses Global Coherence Field (GCF):</span>
<span class="sd">        https://www.researchgate.net/publication/221491705_Speaker_localization_based_on_oriented_global_coherence_field</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        XXs : tensor</span>
<span class="sd">            The covariance matrices of the input signal. The tensor must</span>
<span class="sd">            have the format (batch, time_steps, n_fft/2 + 1, 2, n_mics + n_pairs).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get useful dimensions</span>
        <span class="n">n_fft</span> <span class="o">=</span> <span class="n">XXs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># Generate the steering vector</span>
        <span class="n">As</span> <span class="o">=</span> <span class="n">steering</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">taus</span><span class="p">,</span> <span class="n">n_fft</span><span class="p">)</span>

        <span class="c1"># Perform srp-phat</span>
        <span class="n">doas</span> <span class="o">=</span> <span class="n">SrpPhat</span><span class="o">.</span><span class="n">_srp_phat</span><span class="p">(</span><span class="n">XXs</span><span class="o">=</span><span class="n">XXs</span><span class="p">,</span> <span class="n">As</span><span class="o">=</span><span class="n">As</span><span class="p">,</span> <span class="n">doas</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">doas</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">doas</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_srp_phat</span><span class="p">(</span><span class="n">XXs</span><span class="p">,</span> <span class="n">As</span><span class="p">,</span> <span class="n">doas</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">20</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform srp-phat to find the direction of arrival</span>
<span class="sd">        of the sound source. The result is a tensor containing the directions</span>
<span class="sd">        of arrival (xyz coordinates (in meters) in the direction of the sound source).</span>
<span class="sd">        The output tensor has the format: (batch, time_steps, 3).</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        XXs : tensor</span>
<span class="sd">            The covariance matrices of the input signal. The tensor must</span>
<span class="sd">            have the format (batch, time_steps, n_fft/2 + 1, 2, n_mics + n_pairs).</span>
<span class="sd">        As : tensor</span>
<span class="sd">            The steering vector that cover the all the potential directions</span>
<span class="sd">            of arrival. The tensor must have the format</span>
<span class="sd">            (n_doas, n_fft/2 + 1, 2, n_mics).</span>
<span class="sd">        doas : tensor</span>
<span class="sd">            All the possible directions of arrival that will be scanned. The</span>
<span class="sd">            tensor must have the format (n_doas, 3).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get useful dimensions</span>
        <span class="n">n_mics</span> <span class="o">=</span> <span class="n">As</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

        <span class="c1"># Get the indices for the pairs of microphones</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="n">n_mics</span><span class="p">,</span> <span class="n">n_mics</span><span class="p">)</span>

        <span class="c1"># Generate the demixing vector from the steering vector</span>
        <span class="n">As_1_re</span> <span class="o">=</span> <span class="n">As</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]]</span>
        <span class="n">As_1_im</span> <span class="o">=</span> <span class="n">As</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]]</span>
        <span class="n">As_2_re</span> <span class="o">=</span> <span class="n">As</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]]</span>
        <span class="n">As_2_im</span> <span class="o">=</span> <span class="n">As</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]]</span>
        <span class="n">Ws_re</span> <span class="o">=</span> <span class="n">As_1_re</span> <span class="o">*</span> <span class="n">As_2_re</span> <span class="o">+</span> <span class="n">As_1_im</span> <span class="o">*</span> <span class="n">As_2_im</span>
        <span class="n">Ws_im</span> <span class="o">=</span> <span class="n">As_1_re</span> <span class="o">*</span> <span class="n">As_2_im</span> <span class="o">-</span> <span class="n">As_1_im</span> <span class="o">*</span> <span class="n">As_2_re</span>
        <span class="n">Ws_re</span> <span class="o">=</span> <span class="n">Ws_re</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Ws_re</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">Ws_im</span> <span class="o">=</span> <span class="n">Ws_im</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Ws_im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Get unique covariance values to reduce the number of computations</span>
        <span class="n">XXs_val</span><span class="p">,</span> <span class="n">XXs_idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">XXs</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Perform the phase transform</span>
        <span class="n">XXs_re</span> <span class="o">=</span> <span class="n">XXs_val</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">XXs_im</span> <span class="o">=</span> <span class="n">XXs_val</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">XXs_re</span> <span class="o">=</span> <span class="n">XXs_re</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">XXs_re</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">XXs_re</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">XXs_im</span> <span class="o">=</span> <span class="n">XXs_im</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">XXs_im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">XXs_im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">XXs_abs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">XXs_re</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">XXs_im</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">eps</span>
        <span class="n">XXs_re_norm</span> <span class="o">=</span> <span class="n">XXs_re</span> <span class="o">/</span> <span class="n">XXs_abs</span>
        <span class="n">XXs_im_norm</span> <span class="o">=</span> <span class="n">XXs_im</span> <span class="o">/</span> <span class="n">XXs_abs</span>

        <span class="c1"># Project on the demixing vectors, and keep only real part</span>
        <span class="n">Ys_A</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">XXs_re_norm</span><span class="p">,</span> <span class="n">Ws_re</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">Ys_B</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">XXs_im_norm</span><span class="p">,</span> <span class="n">Ws_im</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">Ys</span> <span class="o">=</span> <span class="n">Ys_A</span> <span class="o">-</span> <span class="n">Ys_B</span>

        <span class="c1"># Get maximum points</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">doas_idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Ys</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Repeat for each frame</span>
        <span class="n">doas</span> <span class="o">=</span> <span class="p">(</span><span class="n">doas</span><span class="p">[</span><span class="n">doas_idx</span><span class="p">,</span> <span class="p">:])[:,</span> <span class="n">XXs_idx</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">return</span> <span class="n">doas</span></div>


<div class="viewcode-block" id="Music"><a class="viewcode-back" href="../../../speechbrain.processing.multi_mic.html#speechbrain.processing.multi_mic.Music">[docs]</a><span class="k">class</span> <span class="nc">Music</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Multiple Signal Classification (MUSIC) localization.</span>

<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    mics : tensor</span>
<span class="sd">        The cartesian coordinates (xyz) in meters of each microphone.</span>
<span class="sd">        The tensor must have the following format (n_mics, 3).</span>
<span class="sd">    space : string</span>
<span class="sd">        If this parameter is set to &#39;sphere&#39;, the localization will</span>
<span class="sd">        be done in 3D by searching in a sphere of possible doas. If</span>
<span class="sd">        it set to &#39;circle&#39;, the search will be done in 2D by searching</span>
<span class="sd">        in a circle. By default, this parameter is set to &#39;sphere&#39;.</span>
<span class="sd">        Note: The &#39;circle&#39; option isn&#39;t implemented yet.</span>
<span class="sd">    sample_rate : int</span>
<span class="sd">        The sample rate in Hertz of the signals to perform SRP-PHAT on.</span>
<span class="sd">        By default, this parameter is set to 16000 Hz.</span>
<span class="sd">    speed_sound : float</span>
<span class="sd">        The speed of sound in the medium. The speed is expressed in meters</span>
<span class="sd">        per second and the default value of this parameter is 343 m/s.</span>
<span class="sd">    eps : float</span>
<span class="sd">        A small value to avoid errors like division by 0. The default value</span>
<span class="sd">        of this parameter is 1e-20.</span>
<span class="sd">    n_sig : int</span>
<span class="sd">        An estimation of the number of sound sources. The default value is set</span>
<span class="sd">        to one source.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; import torch</span>

<span class="sd">    &gt;&gt;&gt; from speechbrain.dataio.dataio import read_audio</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.processing.features import STFT</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.processing.multi_mic import Covariance</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.processing.multi_mic import SrpPhat</span>

<span class="sd">    &gt;&gt;&gt; xs_speech = read_audio(&#39;samples/audio_samples/multi_mic/speech_-0.82918_0.55279_-0.082918.flac&#39;)</span>
<span class="sd">    &gt;&gt;&gt; xs_noise = read_audio(&#39;samples/audio_samples/multi_mic/noise_diffuse.flac&#39;)</span>
<span class="sd">    &gt;&gt;&gt; fs = 16000</span>

<span class="sd">    &gt;&gt;&gt; xs_speech = xs_speech.unsqueeze(0) # [batch, time, channels]</span>
<span class="sd">    &gt;&gt;&gt; xs_noise = xs_noise.unsqueeze(0)</span>

<span class="sd">    &gt;&gt;&gt; ss1 = xs_speech</span>
<span class="sd">    &gt;&gt;&gt; ns1 = 0.05 * xs_noise</span>
<span class="sd">    &gt;&gt;&gt; xs1 = ss1 + ns1</span>

<span class="sd">    &gt;&gt;&gt; ss2 = xs_speech</span>
<span class="sd">    &gt;&gt;&gt; ns2 = 0.20 * xs_noise</span>
<span class="sd">    &gt;&gt;&gt; xs2 = ss2 + ns2</span>

<span class="sd">    &gt;&gt;&gt; ss = torch.cat((ss1,ss2), dim=0)</span>
<span class="sd">    &gt;&gt;&gt; ns = torch.cat((ns1,ns2), dim=0)</span>
<span class="sd">    &gt;&gt;&gt; xs = torch.cat((xs1,xs2), dim=0)</span>

<span class="sd">    &gt;&gt;&gt; mics = torch.zeros((4,3), dtype=torch.float)</span>
<span class="sd">    &gt;&gt;&gt; mics[0,:] = torch.FloatTensor([-0.05, -0.05, +0.00])</span>
<span class="sd">    &gt;&gt;&gt; mics[1,:] = torch.FloatTensor([-0.05, +0.05, +0.00])</span>
<span class="sd">    &gt;&gt;&gt; mics[2,:] = torch.FloatTensor([+0.05, +0.05, +0.00])</span>
<span class="sd">    &gt;&gt;&gt; mics[3,:] = torch.FloatTensor([+0.05, +0.05, +0.00])</span>

<span class="sd">    &gt;&gt;&gt; stft = STFT(sample_rate=fs)</span>
<span class="sd">    &gt;&gt;&gt; cov = Covariance()</span>
<span class="sd">    &gt;&gt;&gt; music = Music(mics=mics)</span>

<span class="sd">    &gt;&gt;&gt; Xs = stft(xs)</span>
<span class="sd">    &gt;&gt;&gt; XXs = cov(Xs)</span>
<span class="sd">    &gt;&gt;&gt; doas = music(XXs)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mics</span><span class="p">,</span>
        <span class="n">space</span><span class="o">=</span><span class="s2">&quot;sphere&quot;</span><span class="p">,</span>
        <span class="n">sample_rate</span><span class="o">=</span><span class="mi">16000</span><span class="p">,</span>
        <span class="n">speed_sound</span><span class="o">=</span><span class="mf">343.0</span><span class="p">,</span>
        <span class="n">eps</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span>
        <span class="n">n_sig</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>

        <span class="c1"># Generate the doas</span>
        <span class="k">if</span> <span class="n">space</span> <span class="o">==</span> <span class="s2">&quot;sphere&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">doas</span> <span class="o">=</span> <span class="n">sphere</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">space</span> <span class="o">==</span> <span class="s2">&quot;circle&quot;</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># Generate associated taus with the doas</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">taus</span> <span class="o">=</span> <span class="n">doas2taus</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">doas</span><span class="p">,</span> <span class="n">mics</span><span class="o">=</span><span class="n">mics</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">speed_sound</span>
        <span class="p">)</span>

        <span class="c1"># Save epsilon</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="n">eps</span>

        <span class="c1"># Save number of signals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_sig</span> <span class="o">=</span> <span class="n">n_sig</span>

<div class="viewcode-block" id="Music.forward"><a class="viewcode-back" href="../../../speechbrain.processing.multi_mic.html#speechbrain.processing.multi_mic.Music.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">XXs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform MUSIC localization on a signal by computing a steering</span>
<span class="sd">        vector and then by using the utility function _music to extract the doas.</span>
<span class="sd">        The result is a tensor containing the directions of arrival (xyz coordinates</span>
<span class="sd">        (in meters) in the direction of the sound source). The output tensor</span>
<span class="sd">        has the format (batch, time_steps, 3).</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        XXs : tensor</span>
<span class="sd">            The covariance matrices of the input signal. The tensor must</span>
<span class="sd">            have the format (batch, time_steps, n_fft/2 + 1, 2, n_mics + n_pairs).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get useful dimensions</span>
        <span class="n">n_fft</span> <span class="o">=</span> <span class="n">XXs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># Generate the steering vector</span>
        <span class="n">As</span> <span class="o">=</span> <span class="n">steering</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">taus</span><span class="p">,</span> <span class="n">n_fft</span><span class="p">)</span>

        <span class="c1"># Perform music</span>
        <span class="n">doas</span> <span class="o">=</span> <span class="n">Music</span><span class="o">.</span><span class="n">_music</span><span class="p">(</span>
            <span class="n">XXs</span><span class="o">=</span><span class="n">XXs</span><span class="p">,</span> <span class="n">As</span><span class="o">=</span><span class="n">As</span><span class="p">,</span> <span class="n">doas</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">doas</span><span class="p">,</span> <span class="n">n_sig</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_sig</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">doas</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_music</span><span class="p">(</span><span class="n">XXs</span><span class="p">,</span> <span class="n">As</span><span class="p">,</span> <span class="n">doas</span><span class="p">,</span> <span class="n">n_sig</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">20</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform multiple signal classification to find the</span>
<span class="sd">        direction of arrival of the sound source. The result</span>
<span class="sd">        has the format: (batch, time_steps, 3).</span>

<span class="sd">        Arguments</span>
<span class="sd">        ---------</span>
<span class="sd">        XXs : tensor</span>
<span class="sd">            The covariance matrices of the input signal. The tensor must</span>
<span class="sd">            have the format (batch, time_steps, n_fft/2 + 1, 2, n_mics + n_pairs).</span>
<span class="sd">        As : tensor</span>
<span class="sd">            The steering vector that covers the all the potential directions</span>
<span class="sd">            of arrival. The tensor must have the format.</span>
<span class="sd">            (n_doas, n_fft/2 + 1, 2, n_mics).</span>
<span class="sd">        doas : tensor</span>
<span class="sd">            All the possible directions of arrival that will be scanned. The</span>
<span class="sd">            tensor must have the format (n_doas, 3).</span>
<span class="sd">        n_sig : int</span>
<span class="sd">            The number of signals in the signal + noise subspace (default is 1).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Collecting data</span>
        <span class="n">n_mics</span> <span class="o">=</span> <span class="n">As</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">n_doas</span> <span class="o">=</span> <span class="n">As</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n_bins</span> <span class="o">=</span> <span class="n">As</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">svd_range</span> <span class="o">=</span> <span class="n">n_mics</span> <span class="o">-</span> <span class="n">n_sig</span>

        <span class="c1"># Get unique values to reduce computations</span>
        <span class="n">XXs_val</span><span class="p">,</span> <span class="n">XXs_idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">XXs</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Singular value decomposition</span>
        <span class="n">Us</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">eig</span><span class="o">.</span><span class="n">svdl</span><span class="p">(</span><span class="n">XXs_val</span><span class="p">)</span>

        <span class="c1"># Format for the projection</span>
        <span class="n">Us</span> <span class="o">=</span> <span class="n">Us</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_doas</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">Us_re</span> <span class="o">=</span> <span class="n">Us</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">svd_range</span><span class="p">),</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">Us_im</span> <span class="o">=</span> <span class="n">Us</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">svd_range</span><span class="p">),</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Fixing the format of the steering vector</span>
        <span class="n">As</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">As</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
            <span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">As</span> <span class="o">=</span> <span class="n">As</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">Us</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Us</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">As_re</span> <span class="o">=</span> <span class="n">As</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">As_im</span> <span class="o">=</span> <span class="n">As</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Applying MUSIC&#39;s formula</span>
        <span class="n">As_mm_Us_re</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">As_re</span><span class="p">,</span> <span class="n">Us_re</span><span class="p">)</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">As_im</span><span class="p">,</span> <span class="n">Us_im</span><span class="p">)</span>
        <span class="n">As_mm_Us_im</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">As_re</span><span class="p">,</span> <span class="n">Us_im</span><span class="p">)</span> <span class="o">-</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">As_im</span><span class="p">,</span> <span class="n">Us_re</span><span class="p">)</span>

        <span class="n">As_mm_Us_abs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">As_mm_Us_re</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">As_mm_Us_im</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">As_mm_Us_sum</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">As_mm_Us_abs</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

        <span class="n">As_As_abs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">As_re</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">As_im</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

        <span class="n">Ps</span> <span class="o">=</span> <span class="p">(</span><span class="n">As_As_abs</span> <span class="o">/</span> <span class="p">(</span><span class="n">As_mm_Us_sum</span> <span class="o">+</span> <span class="n">eps</span><span class="p">))</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

        <span class="n">Ys</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Ps</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_bins</span>

        <span class="c1"># Get maximum points</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">doas_idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Ys</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">doas</span> <span class="o">=</span> <span class="p">(</span><span class="n">doas</span><span class="p">[</span><span class="n">doas_idx</span><span class="p">,</span> <span class="p">:])[:,</span> <span class="n">XXs_idx</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">return</span> <span class="n">doas</span></div>


<div class="viewcode-block" id="doas2taus"><a class="viewcode-back" href="../../../speechbrain.processing.multi_mic.html#speechbrain.processing.multi_mic.doas2taus">[docs]</a><span class="k">def</span> <span class="nf">doas2taus</span><span class="p">(</span><span class="n">doas</span><span class="p">,</span> <span class="n">mics</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mf">343.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function converts directions of arrival (xyz coordinates</span>
<span class="sd">    expressed in meters) in time differences of arrival (expressed in</span>
<span class="sd">    samples). The result has the following format: (batch, time_steps, n_mics).</span>

<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    doas : tensor</span>
<span class="sd">        The directions of arrival expressed with cartesian coordinates (xyz)</span>
<span class="sd">        in meters. The tensor must have the following format: (batch, time_steps, 3).</span>
<span class="sd">    mics : tensor</span>
<span class="sd">        The cartesian position (xyz) in meters of each microphone.</span>
<span class="sd">        The tensor must have the following format (n_mics, 3).</span>
<span class="sd">    fs : int</span>
<span class="sd">        The sample rate in Hertz of the signals.</span>
<span class="sd">    c : float</span>
<span class="sd">        The speed of sound in the medium. The speed is expressed in meters</span>
<span class="sd">        per second and the default value of this parameter is 343 m/s.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; import torch</span>

<span class="sd">    &gt;&gt;&gt; from speechbrain.dataio.dataio import read_audio</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.processing.multi_mic import sphere, doas2taus</span>

<span class="sd">    &gt;&gt;&gt; xs = read_audio(&#39;samples/audio_samples/multi_mic/speech_-0.82918_0.55279_-0.082918.flac&#39;)</span>
<span class="sd">    &gt;&gt;&gt; xs = xs.unsqueeze(0) # [batch, time, channels]</span>
<span class="sd">    &gt;&gt;&gt; fs = 16000</span>
<span class="sd">    &gt;&gt;&gt; mics = torch.zeros((4,3), dtype=torch.float)</span>
<span class="sd">    &gt;&gt;&gt; mics[0,:] = torch.FloatTensor([-0.05, -0.05, +0.00])</span>
<span class="sd">    &gt;&gt;&gt; mics[1,:] = torch.FloatTensor([-0.05, +0.05, +0.00])</span>
<span class="sd">    &gt;&gt;&gt; mics[2,:] = torch.FloatTensor([+0.05, +0.05, +0.00])</span>
<span class="sd">    &gt;&gt;&gt; mics[3,:] = torch.FloatTensor([+0.05, +0.05, +0.00])</span>

<span class="sd">    &gt;&gt;&gt; doas = sphere()</span>
<span class="sd">    &gt;&gt;&gt; taus = doas2taus(doas, mics, fs)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">taus</span> <span class="o">=</span> <span class="p">(</span><span class="n">fs</span> <span class="o">/</span> <span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">doas</span><span class="p">,</span> <span class="n">mics</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">taus</span></div>


<div class="viewcode-block" id="tdoas2taus"><a class="viewcode-back" href="../../../speechbrain.processing.multi_mic.html#speechbrain.processing.multi_mic.tdoas2taus">[docs]</a><span class="k">def</span> <span class="nf">tdoas2taus</span><span class="p">(</span><span class="n">tdoas</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This function selects the tdoas of each channel and put them</span>
<span class="sd">    in a tensor. The result has the following format:</span>
<span class="sd">    (batch, time_steps, n_mics).</span>

<span class="sd">    Arguments:</span>
<span class="sd">    ----------</span>
<span class="sd">    tdoas : tensor</span>
<span class="sd">       The time difference of arrival (TDOA) (in samples) for</span>
<span class="sd">       each timestamp. The tensor has the format</span>
<span class="sd">       (batch, time_steps, n_mics + n_pairs).</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; import torch</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.dataio.dataio import read_audio</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.processing.features import STFT</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.processing.multi_mic import Covariance</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.processing.multi_mic import GccPhat, tdoas2taus</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; xs_speech = read_audio(</span>
<span class="sd">    ...    &#39;samples/audio_samples/multi_mic/speech_-0.82918_0.55279_-0.082918.flac&#39;</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; xs_noise = read_audio(&#39;samples/audio_samples/multi_mic/noise_diffuse.flac&#39;)</span>
<span class="sd">    &gt;&gt;&gt; xs = xs_speech + 0.05 * xs_noise</span>
<span class="sd">    &gt;&gt;&gt; xs = xs.unsqueeze(0)</span>
<span class="sd">    &gt;&gt;&gt; fs = 16000</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; stft = STFT(sample_rate=fs)</span>
<span class="sd">    &gt;&gt;&gt; cov = Covariance()</span>
<span class="sd">    &gt;&gt;&gt; gccphat = GccPhat()</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; Xs = stft(xs)</span>
<span class="sd">    &gt;&gt;&gt; XXs = cov(Xs)</span>
<span class="sd">    &gt;&gt;&gt; tdoas = gccphat(XXs)</span>
<span class="sd">    &gt;&gt;&gt; taus = tdoas2taus(tdoas)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_pairs</span> <span class="o">=</span> <span class="n">tdoas</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">tdoas</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">n_channels</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(((</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">n_pairs</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">taus</span> <span class="o">=</span> <span class="n">tdoas</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_channels</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">taus</span></div>


<div class="viewcode-block" id="steering"><a class="viewcode-back" href="../../../speechbrain.processing.multi_mic.html#speechbrain.processing.multi_mic.steering">[docs]</a><span class="k">def</span> <span class="nf">steering</span><span class="p">(</span><span class="n">taus</span><span class="p">,</span> <span class="n">n_fft</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This function computes a steering vector by using the time differences</span>
<span class="sd">    of arrival for each channel (in samples) and the number of bins (n_fft).</span>
<span class="sd">    The result has the following format: (batch, time_step, n_fft/2 + 1, 2, n_mics).</span>

<span class="sd">    Arguments:</span>
<span class="sd">    ----------</span>
<span class="sd">    taus : tensor</span>
<span class="sd">        The time differences of arrival for each channel. The tensor must have</span>
<span class="sd">        the following format: (batch, time_steps, n_mics).</span>

<span class="sd">    n_fft : int</span>
<span class="sd">        The number of bins resulting of the STFT. It is assumed that the</span>
<span class="sd">        argument &quot;onesided&quot; was set to True for the STFT.</span>

<span class="sd">    Example:</span>
<span class="sd">    --------f</span>
<span class="sd">    &gt;&gt;&gt; import torch</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.dataio.dataio import read_audio</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.processing.features import STFT</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.processing.multi_mic import Covariance</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.processing.multi_mic import GccPhat, tdoas2taus, steering</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; xs_speech = read_audio(</span>
<span class="sd">    ...    &#39;samples/audio_samples/multi_mic/speech_-0.82918_0.55279_-0.082918.flac&#39;</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; xs_noise = read_audio(&#39;samples/audio_samples/multi_mic/noise_diffuse.flac&#39;)</span>
<span class="sd">    &gt;&gt;&gt; xs = xs_speech + 0.05 * xs_noise</span>
<span class="sd">    &gt;&gt;&gt; xs = xs.unsqueeze(0) # [batch, time, channels]</span>
<span class="sd">    &gt;&gt;&gt; fs = 16000</span>

<span class="sd">    &gt;&gt;&gt; stft = STFT(sample_rate=fs)</span>
<span class="sd">    &gt;&gt;&gt; cov = Covariance()</span>
<span class="sd">    &gt;&gt;&gt; gccphat = GccPhat()</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; Xs = stft(xs)</span>
<span class="sd">    &gt;&gt;&gt; n_fft = Xs.shape[2]</span>
<span class="sd">    &gt;&gt;&gt; XXs = cov(Xs)</span>
<span class="sd">    &gt;&gt;&gt; tdoas = gccphat(XXs)</span>
<span class="sd">    &gt;&gt;&gt; taus = tdoas2taus(tdoas)</span>
<span class="sd">    &gt;&gt;&gt; As = steering(taus, n_fft)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Collecting useful numbers</span>
    <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.141592653589793</span>

    <span class="n">frame_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">n_fft</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Computing the different parts of the steering vector</span>
    <span class="n">omegas</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_fft</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">taus</span><span class="o">.</span><span class="n">device</span><span class="p">)</span> <span class="o">/</span> <span class="n">frame_size</span>
    <span class="n">omegas</span> <span class="o">=</span> <span class="n">omegas</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">taus</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
    <span class="n">taus</span> <span class="o">=</span> <span class="n">taus</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">taus</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
        <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">taus</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">n_fft</span><span class="p">,)</span>
    <span class="p">)</span>

    <span class="c1"># Assembling the steering vector</span>
    <span class="n">a_re</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="o">-</span><span class="n">omegas</span> <span class="o">*</span> <span class="n">taus</span><span class="p">)</span>
    <span class="n">a_im</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="o">-</span><span class="n">omegas</span> <span class="o">*</span> <span class="n">taus</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">a_re</span><span class="p">,</span> <span class="n">a_im</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_re</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">a</span></div>


<div class="viewcode-block" id="sphere"><a class="viewcode-back" href="../../../speechbrain.processing.multi_mic.html#speechbrain.processing.multi_mic.sphere">[docs]</a><span class="k">def</span> <span class="nf">sphere</span><span class="p">(</span><span class="n">levels_count</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; This function generates cartesian coordinates (xyz) for a set</span>
<span class="sd">    of points forming a 3D sphere. The coordinates are expressed in</span>
<span class="sd">    meters and can be used as doas. The result has the format:</span>
<span class="sd">    (n_points, 3).</span>

<span class="sd">    Arguments</span>
<span class="sd">    ---------</span>
<span class="sd">    levels_count : int</span>
<span class="sd">        A number proportional to the number of points that the user</span>
<span class="sd">        wants to generate.</span>
<span class="sd">            - If levels_count = 1, then the sphere will have 42 points</span>
<span class="sd">            - If levels_count = 2, then the sphere will have 162 points</span>
<span class="sd">            - If levels_count = 3, then the sphere will have 642 points</span>
<span class="sd">            - If levels_count = 4, then the sphere will have 2562 points</span>
<span class="sd">            - If levels_count = 5, then the sphere will have 10242 points</span>
<span class="sd">            - ...</span>
<span class="sd">        By default, levels_count is set to 4.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; import torch</span>
<span class="sd">    &gt;&gt;&gt; from speechbrain.processing.multi_mic import sphere</span>
<span class="sd">    &gt;&gt;&gt; doas = sphere()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Generate points at level 0</span>

    <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="mf">5.0</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="mf">5.0</span>
    <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">/</span> <span class="mf">5.0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">5.0</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="n">pi</span> <span class="o">=</span> <span class="mf">3.141592654</span>

    <span class="n">pts</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">12</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">FloatTensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">pts</span><span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">FloatTensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">pts</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">/</span> <span class="mf">5.0</span><span class="p">)</span>
    <span class="n">pts</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">/</span> <span class="mf">5.0</span><span class="p">)</span>
    <span class="n">pts</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span>
    <span class="n">pts</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">11</span><span class="p">),</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">/</span> <span class="mf">5.0</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">pts</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">11</span><span class="p">),</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">/</span> <span class="mf">5.0</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">pts</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">11</span><span class="p">),</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">h</span>

    <span class="c1"># Generate triangles at level 0</span>

    <span class="n">trs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">)</span>

    <span class="n">trs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">trs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">trs</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
    <span class="n">trs</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
    <span class="n">trs</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>

    <span class="n">trs</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">trs</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
    <span class="n">trs</span><span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
    <span class="n">trs</span><span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
    <span class="n">trs</span><span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="n">trs</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
    <span class="n">trs</span><span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
    <span class="n">trs</span><span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
    <span class="n">trs</span><span class="p">[</span><span class="mi">13</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
    <span class="n">trs</span><span class="p">[</span><span class="mi">14</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>

    <span class="n">trs</span><span class="p">[</span><span class="mi">15</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="mi">11</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span>
    <span class="n">trs</span><span class="p">[</span><span class="mi">16</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="mi">11</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
    <span class="n">trs</span><span class="p">[</span><span class="mi">17</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="mi">11</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">])</span>
    <span class="n">trs</span><span class="p">[</span><span class="mi">18</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="mi">11</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
    <span class="n">trs</span><span class="p">[</span><span class="mi">19</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="mi">11</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>

    <span class="c1"># Generate next levels</span>

    <span class="k">for</span> <span class="n">levels_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">levels_count</span><span class="p">):</span>

        <span class="c1">#      0</span>
        <span class="c1">#     / \</span>
        <span class="c1">#    A---B</span>
        <span class="c1">#   / \ / \</span>
        <span class="c1">#  1---C---2</span>

        <span class="n">trs_count</span> <span class="o">=</span> <span class="n">trs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">subtrs_count</span> <span class="o">=</span> <span class="n">trs_count</span> <span class="o">*</span> <span class="mi">4</span>

        <span class="n">subtrs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">subtrs_count</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">)</span>

        <span class="n">subtrs</span><span class="p">[</span><span class="mi">0</span> <span class="o">*</span> <span class="n">trs_count</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">trs_count</span><span class="p">),</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">trs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">subtrs</span><span class="p">[</span><span class="mi">0</span> <span class="o">*</span> <span class="n">trs_count</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">trs_count</span><span class="p">),</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">trs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">subtrs</span><span class="p">[</span><span class="mi">0</span> <span class="o">*</span> <span class="n">trs_count</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">trs_count</span><span class="p">),</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">trs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">subtrs</span><span class="p">[</span><span class="mi">0</span> <span class="o">*</span> <span class="n">trs_count</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">trs_count</span><span class="p">),</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">trs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">subtrs</span><span class="p">[</span><span class="mi">0</span> <span class="o">*</span> <span class="n">trs_count</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">trs_count</span><span class="p">),</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">trs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">subtrs</span><span class="p">[</span><span class="mi">0</span> <span class="o">*</span> <span class="n">trs_count</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">trs_count</span><span class="p">),</span> <span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">trs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">subtrs</span><span class="p">[</span><span class="mi">1</span> <span class="o">*</span> <span class="n">trs_count</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">trs_count</span><span class="p">),</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">trs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">subtrs</span><span class="p">[</span><span class="mi">1</span> <span class="o">*</span> <span class="n">trs_count</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">trs_count</span><span class="p">),</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">trs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">subtrs</span><span class="p">[</span><span class="mi">1</span> <span class="o">*</span> <span class="n">trs_count</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">trs_count</span><span class="p">),</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">trs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">subtrs</span><span class="p">[</span><span class="mi">1</span> <span class="o">*</span> <span class="n">trs_count</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">trs_count</span><span class="p">),</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">trs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">subtrs</span><span class="p">[</span><span class="mi">1</span> <span class="o">*</span> <span class="n">trs_count</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">trs_count</span><span class="p">),</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">trs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">subtrs</span><span class="p">[</span><span class="mi">1</span> <span class="o">*</span> <span class="n">trs_count</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">trs_count</span><span class="p">),</span> <span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">trs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>

        <span class="n">subtrs</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">trs_count</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">trs_count</span><span class="p">),</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">trs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">subtrs</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">trs_count</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">trs_count</span><span class="p">),</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">trs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">subtrs</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">trs_count</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">trs_count</span><span class="p">),</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">trs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">subtrs</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">trs_count</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">trs_count</span><span class="p">),</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">trs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">subtrs</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">trs_count</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">trs_count</span><span class="p">),</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">trs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">subtrs</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">trs_count</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">trs_count</span><span class="p">),</span> <span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">trs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>

        <span class="n">subtrs</span><span class="p">[</span><span class="mi">3</span> <span class="o">*</span> <span class="n">trs_count</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">trs_count</span><span class="p">),</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">trs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">subtrs</span><span class="p">[</span><span class="mi">3</span> <span class="o">*</span> <span class="n">trs_count</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">trs_count</span><span class="p">),</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">trs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">subtrs</span><span class="p">[</span><span class="mi">3</span> <span class="o">*</span> <span class="n">trs_count</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">trs_count</span><span class="p">),</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">trs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">subtrs</span><span class="p">[</span><span class="mi">3</span> <span class="o">*</span> <span class="n">trs_count</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">trs_count</span><span class="p">),</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">trs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">subtrs</span><span class="p">[</span><span class="mi">3</span> <span class="o">*</span> <span class="n">trs_count</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">trs_count</span><span class="p">),</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">trs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">subtrs</span><span class="p">[</span><span class="mi">3</span> <span class="o">*</span> <span class="n">trs_count</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">trs_count</span><span class="p">),</span> <span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">trs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">subtrs_flatten</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span>
            <span class="p">(</span><span class="n">subtrs</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">subtrs</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]],</span> <span class="n">subtrs</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>
        <span class="n">subtrs_sorted</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">subtrs_flatten</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">index_max</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">subtrs_sorted</span><span class="p">)</span>

        <span class="n">subtrs_scalar</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">subtrs_sorted</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">index_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">subtrs_sorted</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">unique_scalar</span><span class="p">,</span> <span class="n">unique_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
            <span class="n">subtrs_scalar</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="n">unique_values</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="n">unique_scalar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">unique_scalar</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>

        <span class="n">unique_values</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">floor_divide</span><span class="p">(</span><span class="n">unique_scalar</span><span class="p">,</span> <span class="n">index_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">unique_values</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_scalar</span> <span class="o">-</span> <span class="n">unique_values</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span>
            <span class="n">index_max</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="p">)</span>

        <span class="n">trs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">unique_indices</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">pts</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="n">unique_values</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">pts</span><span class="p">[</span><span class="n">unique_values</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">:]</span>
        <span class="n">pts</span> <span class="o">/=</span> <span class="n">torch</span><span class="o">.</span><span class="n">repeat_interleave</span><span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pts</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">pts</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2021, SpeechBrain

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>